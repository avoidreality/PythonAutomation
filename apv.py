import re
import logging




formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

apv_logger = logging.getLogger('apv-log')
if not apv_logger.handlers:
    apv_fh = logging.FileHandler('apv.log')
    apv_logger.setLevel(logging.DEBUG)
    apv_fh.setFormatter(formatter)
    apv_logger.addHandler(apv_fh) #add the file handler to the logger


"""'apv.py' module - to programmatically update sync/diff scripts. """
#store line matches here
MATCHES = []


def deleteYourself(path_to_sync_script, delete_statement):
    """delete lines from the file - only delete if delete_statement variable is not blank or equal to None. """
    if delete_statement != None and delete_statement != '':

        eraserhead = None
        eraserfoot = None

        apv_logger.debug("At the top of the 'delete yourself' function.")
        count = 0 #keep track of the number of rows to delete with this variable

        new_file = [] # this list is used to create the new file
        
        apv_logger.debug("Opening this file %s" % path_to_sync_script)
        
        with open(path_to_sync_script) as f:
            lines = f.readlines()

            #loop through the lanes of the file based on the statement number found and
            #change the part of the line that says "INSTALL" to "UPGRADE" 
            for i in range(len(lines)):
                apv_logger.info("Currently at line %d." % i)

                if re.search('\\b'+delete_statement+ " := 'DELETE FROM foo.foo_bar.*;$",lines[i]):
                    apv_logger.debug("[ERASERHEAD] This is the line to delete: %s. I found '%s' in the line. At line %d" % (lines[i], delete_statement, i))
                    eraserhead = i
                    
                    
                    for i in range(eraserhead, len(lines) - 1):
                        if re.search('^END;$', lines[i]):
                            eraserfoot = i
                            apv_logger.debug(f" Found the ending block for the delete block at line: {i}")
                            break
                        
                        
                else:
                    new_file.append(lines[i])

    else:
        raise Exception(f'apv.deleteYourself''s delete_statement is empty...')

    del new_file[eraserhead -4: eraserfoot + 1] #delete the previous 4 lines from the DELETE AP line. This is the DECLARE, variables, and BEGIN statements. Delete the END and the forward slash also.
    lines_to_delete = eraserfoot - eraserhead
    apv_logger.info(f"[+] Need to delete {eraserfoot - eraserhead} lines plus 5 more.")
    apv_logger.info("Total lines to delete is around: %d" % (lines_to_delete + 4 + 1))
    print(f"[+] Total lines to delete is around: %d" % (lines_to_delete + 4 + 1))

    with open(path_to_sync_script, 'w') as rc:
        for codes in new_file:
            rc.write(codes)
    
    apv_logger.info("[+] RC written sans foo_bar DELETE statements. File name %s" % path_to_sync_script)

    

def modify(path_to_sync_script, statement, vertical_direction):
    """This function modifies the sync script based on if the script is for an upgrade or downgrade.
       The 'statement' argument is the 'statement#' RedGate (RG) generates in sync scripts.
       'vertical_direction' parameter needs either 'UPGRADE' or 'DOWNGRADE' as an argument.
       The 'path_to_sync_script' is the absolute path to the FOO sync script generated by RG. 
    """
    apv_logger.debug("At the top of the 'modify' function.")
    
    new_file = [] # this list is used to create the new file

    done = False

    apv_logger.debug("Opening this file %s" % path_to_sync_script)
    
    with open(path_to_sync_script) as f:
        lines = f.readlines()

        #loop through the lanes of the file based on the statement number found and
        #change the part of the line that says "INSTALL" to "UPGRADE" 
        for i in range(len(lines)):
            
            apv_logger.info("Currently at line %d." % i)
            if re.search("^\s+" + statement + " := 'INSERT INTO foo.foo_bar.*$", lines[i]):
                        apv_logger.debug(f"Insert statement located at line {i}")
                        apv_logger.debug(r"Found at line #%d the INSERT statement definition: %s" % (i,lines[i]))
                        new_file.append(lines[i])
                        the_insert = lines[i]

                        starts_with = "\\sEXECUTE\\sIMMEDIATE\\s" + statement +"\\b"   #find the lines below the actual insert statement with the parameterized SQL 
                        
                        apv_logger.info("Looking for a line that starts with this: %s" % starts_with.strip())
                        
                        while not re.search('^END;$', lines[i]):
                            apv_logger.debug("[~]In 'while' this line = %s" % lines[i])
                           
                            
                            if re.search(starts_with, lines[i]) or lines[i] == the_insert:
                                apv_logger.info("[~]This line is important: %s" % repr(lines[i]))

                                #look for a line that has "INSTALL" in it then sub it with the v_dir variable
                                if re.search('\\bINSTALL\\b', lines[i]):
                                    apv_logger.debug(r"[~] Found a match for '\\bINSTALL\\b'")
                                    MATCHES.append(i) #add the line number to the global list
                                
                                    m2 = re.sub('\\bINSTALL\\b', '%s' % vertical_direction, lines[i])
                                    if m2:
                                        #apv_logger.debug("[~] The regex returned object is of type: %s" % str(type(m2)))
                                        #apv_logger.debug("[~] The regex returned variable 'm2' = %s " % str(m2))
                                        #apv_logger.debug("[~] The line from the file is: %s" % lines[i])
                                        #apv_logger.debug("[~] The regex sub for the line is: %s. Adding this regex sub line to the new file" % str(m2))
                                        #add the substituted line to the new file
                                        #new_file.append(m2)
                                        #modify the TO_DATE(hard-coded date string) to sysdate
                                        
                                        
                                        m3 = re.sub('TO_DATE[(].*[)]', 'sysdate', m2)
                                        if m3:
                                            apv_logger.debug("[~] Going to replace the 'to_date' string with 'sysdate' now.")
                                            apv_logger.debug(f"[~] Date updated for line number: {i}")
                                            apv_logger.debug(f"[~] m3 = {m3}")
                                            new_file.append(m3)
                                            
                                       
                                            
                            i += 1 #increment this inner looping block regardless if match is found for "INSTALL"    
            else:
                if i not in MATCHES:
                    new_file.append(lines[i])
                else:
                    print("This line #%d is in the MATCHES list - not adding." % i)
                    apv_logger.info("This line #%d is in the MATCHES list - not adding." % i)
                    
                
                
        with open(path_to_sync_script, 'w') as rc:
            for codes in new_file:
                rc.write(codes)
        #print("[+] New RITE_COMMON sync script written to disk. File name %s" % path_to_sync_script)
        apv_logger.info("[+] New FOO sync script written to disk with updated INSERTS. File name %s" % path_to_sync_script)

        #need to write these changed lines back to the diff/sync script file

def rc_apv(path_to_sync_script, vertical_direction='UPGRADE'):
    """ This function locates the statement# that contain INSERTs and DELETEs for ... sync/diff scripts generated by Red Gate (RG) Data Compare for Oracle.
        Then the function calls 'modify()' to actually remove the DELETE statements and
        change a column in the INSERTs and write the changes to disk.
        
   
    """
    apv_logger.info("At the top of the 'rc_apv' function")
    
    delete_statement = ''
    insert_statement = ''

    with open(path_to_sync_script, 'r') as f:
        apv_logger.debug(f"File openened")
        
        lines = f.readlines()
        apv_logger.debug(f"Read these lines: {lines}")

        #finding the insert and delete statements
        for x in lines:
            
                
            #to find the statement numbers

            

            if 'DELETE' in x and 'foo_bar' in x:
                #find the statement numbers for lines with 'foo_bar' in them
                apv_logger.debug("Found a line with both 'DELETE' and 'foo_bar' in it.")
                m = re.search('^^\s+statement[\d+|\s+]', x)
                apv_logger.debug('The regex returned this "m" = %s. The type is: %s' % (str(m), str(type(m))))
                if m:
                    delete_match = m.group()
                    apv_logger.debug("m.group() = %s" % str(m.group()))
                    delete_statement = delete_match.strip() #remove starting and trailing space
                    apv_logger.debug("'delete_statement' = %s" % repr(delete_statement))
                    
                else:
                    apv_logger.debug(f"Something went wrong. No match found for m in DELETE block of rc_apv(). m = {m}")
                    
                

            if 'INSERT' in x and 'foo_bar' in x:
                apv_logger.debug("Found a match with both 'INSERT' and 'foo_bar' in the line.")
                m = re.search('^\s+statement[\d+|\s+]', x) #find the line that begins with 1 or more spaces then the string 'statement' followed by zero or more digits.
                apv_logger.debug('The regex returned this "m" = %s. The type is: %s' % (str(m), str(type(m))))
                if m:
                    insert_match = m.group()
                    apv_logger.debug("m.group() = %s" % str(m.group()))
                    insert_statement = insert_match.strip() #remove starting and trailing space
                    apv_logger.debug("'insert_statement' = %s" % repr(insert_statement))
                else:
                    apv_logger.debug(f"Something went wrong. No match found for m in INSERT block of rc_apv(). m = {m}")
                

        if insert_statement:
            modify(path_to_sync_script, insert_statement, vertical_direction)
            apv_logger.info("""'modify' function called with these args 'path_to_sync_script' = %s
                 'insert_statement' = %s,'vertical_direction' = %s
                """ % (repr(path_to_sync_script), repr(insert_statement), repr(vertical_direction) ))

        if delete_statement:
            deleteYourself(path_to_sync_script, delete_statement)
            apv_logger.info("Found a delete statement. Calling 'deleteYourself()'. The delete statement is: %s" % delete_statement)

        #call the modify function with the data the script found
                            


if __name__ == "__main__":
    x = input("Please specify absolute path to the sync DML script to modify foo_bar: ")
    print("You entered: %s" % x)
    print("The type of 'x' is: %s" % str(type(x)))
    import pathlib
    x = pathlib.Path(x.replace('"', ''))
    if x.exists():
        pass
    else:
        raise Exception("File does not exist!")
    print("The type of 'x' is: %s" % str(type(x)))
    vertical_direction = input("UPGRADE or DOWNGRADE? ")
    if vertical_direction != "UPGRADE":
        if vertical_direction != "DOWNGRADE":
            print("Please specify UPGRADE or DOWNGRADE. Exiting program.")
            exit()
    
    rc_apv(x, vertical_direction)
    print("[+] MATCHES global list = %s" % str(MATCHES))
    print("Script complete.")
            
                
                
